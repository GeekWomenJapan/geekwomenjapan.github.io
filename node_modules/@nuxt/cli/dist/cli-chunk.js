/*!
 * @nuxt/cli v2.5.1 (c) 2016-2019

 * - All the amazing contributors
 * Released under the MIT License.
 * Website: https://nuxtjs.org
*/
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const path = _interopDefault(require('path'));
const consola = _interopDefault(require('consola'));
const minimist = _interopDefault(require('minimist'));
const __chunk_2 = require('./cli-chunk2.js');
const chalk = _interopDefault(require('chalk'));
const fs = require('fs');
const fs__default = _interopDefault(fs);

const commands = {
  start: () => Promise.resolve(require('./cli-chunk4.js')),
  dev: () => Promise.resolve(require('./cli-chunk5.js')),
  build: () => Promise.resolve(require('./cli-chunk6.js')),
  generate: () => Promise.resolve(require('./cli-chunk7.js')),
  help: () => Promise.resolve(require('./cli-chunk8.js'))
};

function getCommand(name) {
  if (!commands[name]) {
    return Promise.resolve(null)
  }
  return commands[name]().then(m => m.default)
}

const _commands = /*#__PURE__*/Object.freeze({
  default: getCommand
});

const localNodeModules = path.resolve(process.cwd(), 'node_modules');

// Prefer importing modules from local node_modules (for NPX and global bin)
async function _import(modulePath) {
  let m;
  for (const mp of [ path.resolve(localNodeModules, modulePath), modulePath ]) {
    try {
      m = await Promise.resolve(require(mp));
    } catch (e) {
      if (e.code !== 'MODULE_NOT_FOUND') {
        throw e
      } else if (mp === modulePath) {
        consola.fatal(
          `Module ${modulePath} not found.\n\n`,
          `Please install missing dependency:\n\n`,
          `Using npm:  npm i ${modulePath}\n\n`,
          `Using yarn: yarn add ${modulePath}`
        );
      }
    }
  }
  return m
}

const builder = () => _import('@nuxt/builder');
const webpack = () => _import('@nuxt/webpack');
const generator = () => _import('@nuxt/generator');
const core = () => _import('@nuxt/core');
const importModule = _import;

const _imports = /*#__PURE__*/Object.freeze({
  builder: builder,
  webpack: webpack,
  generator: generator,
  core: core,
  importModule: importModule
});

var name = "@nuxt/cli";
var version = "2.5.1";

const dependencyNotFoundMessage =
`Please install @nuxt/typescript and rerun the command

${chalk.bold('Using yarn')}
yarn add -D @nuxt/typescript

${chalk.bold('Using npm')}
npm install -D @nuxt/typescript`;

async function detectAndSetupTypeScriptSupport(rootDir, options = {}) {
  const tsConfigPath = path.resolve(rootDir, 'tsconfig.json');

  if (!fs.existsSync(tsConfigPath)) {
    return false
  }

  consola.info(`${chalk.bold.blue('tsconfig.json')} found, enabling TypeScript runtime support`);

  try {
    const { setup } = require('@nuxt/typescript');
    await setup(tsConfigPath, options);
  } catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
      process.stdout.write(__chunk_2.warningBox(dependencyNotFoundMessage, chalk.yellow('An external official dependency is needed to enable TS support')));
      process.exit(1);
    } else {
      throw (e)
    }
  }

  return true
}

class NuxtCommand {
  constructor(cmd = { name: '', usage: '', description: '' }, argv = process.argv.slice(2)) {
    if (!cmd.options) {
      cmd.options = {};
    }
    this.cmd = cmd;

    this._argv = Array.from(argv);
    this._parsedArgv = null; // Lazy evaluate
  }

  static run(cmd, argv) {
    return NuxtCommand.from(cmd, argv).run()
  }

  static from(cmd, argv) {
    if (cmd instanceof NuxtCommand) {
      return cmd
    }
    return new NuxtCommand(cmd, argv)
  }

  async run() {
    if (this.argv.help) {
      this.showHelp();
      return
    }

    if (this.argv.version) {
      this.showVersion();
      return
    }

    if (typeof this.cmd.run !== 'function') {
      return
    }

    let cmdError;

    try {
      await this.cmd.run(this);
    } catch (e) {
      cmdError = e;
    }

    if (this.argv.lock) {
      await this.releaseLock();
    }

    if (this.argv['force-exit']) {
      const forceExitByUser = this.isUserSuppliedArg('force-exit');
      if (cmdError) {
        consola.fatal(cmdError);
      }
      __chunk_2.forceExit(this.cmd.name, forceExitByUser ? false : __chunk_2.forceExitTimeout);
      if (forceExitByUser) {
        return
      }
    }

    if (cmdError) {
      throw cmdError
    }
  }

  showVersion() {
    process.stdout.write(`${name} v${version}\n`);
  }

  showHelp() {
    process.stdout.write(this._getHelp());
  }

  get argv() {
    if (!this._parsedArgv) {
      const minimistOptions = this._getMinimistOptions();
      this._parsedArgv = minimist(this._argv, minimistOptions);
    }
    return this._parsedArgv
  }

  async getNuxtConfig(extraOptions = {}) {
    const rootDir = path.resolve(this.argv._[0] || '.');
    extraOptions._typescript = await detectAndSetupTypeScriptSupport(rootDir, { transpileOnly: this.cmd.name === 'start' });

    const config = await __chunk_2.loadNuxtConfig(this.argv);
    const options = Object.assign(config, extraOptions);

    for (const name of Object.keys(this.cmd.options)) {
      this.cmd.options[name].prepare && this.cmd.options[name].prepare(this, options, this.argv);
    }

    return options
  }

  async getNuxt(options) {
    const { Nuxt } = await core();

    const nuxt = new Nuxt(options);
    await nuxt.ready();

    return nuxt
  }

  async getBuilder(nuxt) {
    const { Builder } = await builder();
    const { BundleBuilder } = await webpack();
    return new Builder(nuxt, BundleBuilder)
  }

  async getGenerator(nuxt) {
    const { Generator } = await generator();
    const builder = await this.getBuilder(nuxt);
    return new Generator(nuxt, builder)
  }

  async setLock(lockRelease) {
    if (lockRelease) {
      if (this._lockRelease) {
        consola.warn(`A previous unreleased lock was found, this shouldn't happen and is probably an error in 'nuxt ${this.cmd.name}' command. The lock will be removed but be aware of potential strange results`);

        await this.releaseLock();
        this._lockRelease = lockRelease;
      } else {
        this._lockRelease = lockRelease;
      }
    }
  }

  async releaseLock() {
    if (this._lockRelease) {
      await this._lockRelease();
      this._lockRelease = undefined;
    }
  }

  isUserSuppliedArg(option) {
    return this._argv.includes(`--${option}`) || this._argv.includes(`--no-${option}`)
  }

  _getDefaultOptionValue(option) {
    return typeof option.default === 'function' ? option.default(this.cmd) : option.default
  }

  _getMinimistOptions() {
    const minimistOptions = {
      alias: {},
      boolean: [],
      string: [],
      default: {}
    };

    for (const name of Object.keys(this.cmd.options)) {
      const option = this.cmd.options[name];

      if (option.alias) {
        minimistOptions.alias[option.alias] = name;
      }
      if (option.type) {
        minimistOptions[option.type].push(option.alias || name);
      }
      if (option.default) {
        minimistOptions.default[option.alias || name] = this._getDefaultOptionValue(option);
      }
    }

    return minimistOptions
  }

  _getHelp() {
    const options = [];
    let maxOptionLength = 0;

    for (const name in this.cmd.options) {
      const option = this.cmd.options[name];

      let optionHelp = '--';
      optionHelp += option.type === 'boolean' && this._getDefaultOptionValue(option) ? 'no-' : '';
      optionHelp += name;
      if (option.alias) {
        optionHelp += `, -${option.alias}`;
      }

      maxOptionLength = Math.max(maxOptionLength, optionHelp.length);
      options.push([ optionHelp, option.description ]);
    }

    const _opts = options.map(([option, description]) => {
      const i = __chunk_2.indent(maxOptionLength + __chunk_2.optionSpaces - option.length);
      return __chunk_2.foldLines(
        option + i + description,
        __chunk_2.startSpaces + maxOptionLength + __chunk_2.optionSpaces * 2,
        __chunk_2.startSpaces + __chunk_2.optionSpaces
      )
    }).join('\n');

    const usage = __chunk_2.foldLines(`Usage: nuxt ${this.cmd.usage} [options]`, __chunk_2.startSpaces);
    const description = __chunk_2.foldLines(this.cmd.description, __chunk_2.startSpaces);
    const opts = __chunk_2.foldLines(`Options:`, __chunk_2.startSpaces) + '\n\n' + _opts;

    let helpText = __chunk_2.colorize(`${usage}\n\n`);
    if (this.cmd.description) {
      helpText += __chunk_2.colorize(`${description}\n\n`);
    }
    if (options.length) {
      helpText += __chunk_2.colorize(`${opts}\n\n`);
    }

    return helpText
  }
}

exports.NuxtCommand = NuxtCommand;
exports._commands = _commands;
exports._imports = _imports;
exports.getCommand = getCommand;
